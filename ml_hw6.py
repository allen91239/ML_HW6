# -*- coding: utf-8 -*-
"""ML_HW6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mV7Ovc3EZkwqr2Dy6ZHJGGyNOUGMpawK
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.image as mpimg

def k_kmeans(img, c):
    img_coordinate = list()
    for i in range(100):
        for j in range(100):
            img_coordinate.append((i+1,j+1))
    ker = kernel(img, img_coordinate)
    plt.imshow(ker)
    plt.savefig("Gram")
    plt.close()
    guess = np.random.randint(c, size=10000)
    predict = np.ones(10000)
    iteration = 1
    while not (guess==predict).all():
        if iteration > 50:
          break
        distance = np.diag(ker)
        dist = distance
        for i in range(c-1):
          dist = np.append(dist, distance)
        dist = dist.reshape(10000, c) # make copies
        predict = guess
        count = np.zeros(c)
        for i in range(c):
          for j in range(10000):
            if guess[j] == i:
              count[i] += 1
        for i in range(c):
            dist[:, i] += -(2/count[i] * np.sum(ker[:, guess==i], axis=1)) + (1/count[i])**2 * np.sum(ker[guess==i][:, guess==i]) # same formula from slide
        guess = np.argmin(dist, axis=1)
        result = guess.reshape((100, 100))
        plt.imshow(result, cmap='rainbow')
        plt.savefig(f'./test{iteration}.png')
        plt.close()
        
        iteration += 1

def kernel(img, img_co):
    ncoord = np.array(img)
    C_D = np.sqrt(((ncoord[:, :, None] - ncoord[:, :, None].T) ** 2).sum(1))
    ncoord = np.array(img_co).reshape(10000,2)
    S_D = np.sqrt(((ncoord[:, :, None] - ncoord[:, :, None].T) ** 2).sum(1))
    #print(S_D)
    gram = np.dot(np.exp(-1 * C_D**2), np.exp(-1 * S_D**2))
    return gram

if __name__ == '__main__':

    img=mpimg.imread('image2.png')
    img = np.array(img).reshape(10000,3)
    clusters = 3
    k_kmeans(img, clusters)
    #plt.imshow(img)
    #plt.show()